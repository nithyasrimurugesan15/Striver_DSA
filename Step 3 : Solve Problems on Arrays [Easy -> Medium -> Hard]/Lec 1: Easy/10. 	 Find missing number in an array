https://leetcode.com/problems/missing-number/

Approaches : brute -> better -> optimal

OPTIMAL(SEE LATER) EXPLNATION N TIME N SPACE

Approach 1 : Brute 

tc o(n^2) and space o(1)

class Solution {
  public int missingNumber(int[] nums) {
    int ans=nums.length;
    for(int i=0;i<=ans;i++)
    {
        boolean f=true;
        for(int j=0;j<ans;j++)
        {
            if(i==nums[j])
            {
                f=false;
            }
        }
        if(f) return i;
    }
    return -1;
  }
}

Approach 2 : Better 

tc o(n) and space o(1)


class Solution {
  public int missingNumber(int[] nums) {
    int N=nums.length;
    int sum = (N * (N + 1)) / 2;
    //int sum=0;
    // for(int i=0;i<nums.length+1;i++)
    // {
    //     sum+=i;
    // }
    int s=0;
    for(int i=0;i<nums.length;i++)
    {
        s+=nums[i];
    }
    return sum-s;
}
}

Approach 3 : better 

o(n) and o(n)

class Solution {
  public int missingNumber(int[] nums) {
    int n = nums.length;
    int[] has=new int[n+1];
    for(int i=0;i<n;i++)
    {
        has[nums[i]]++;
    }
    for(int i=0;i<=n;i++)
    {
        if(has[i]==0)
        {
            return i;
        }
    }
    return -1;
  }
}


Approach 4 : optimal

tc o(n) and space o(1)

class Solution {
  public int missingNumber(int[] nums) {
    int ans = nums.length;

    for (int i = 0; i < nums.length; ++i)
    {
      ans ^= i ^ nums[i];
    }

    return ans;
    }
  }

(OR)

class Solution {
  public int missingNumber(int[] nums) {
    int x1=0;
    int x2=0;
    int n=nums.length;
    for(int i = 0; i<n; i++)
    {
       x1=x1^i;
       x2=x2^nums[i];
    }
    x1=x1^n;
    return x1^x2;
  }
}
