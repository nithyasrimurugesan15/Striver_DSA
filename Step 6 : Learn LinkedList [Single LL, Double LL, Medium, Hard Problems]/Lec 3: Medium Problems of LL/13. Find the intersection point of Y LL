https://leetcode.com/problems/intersection-of-two-linked-lists/

Approach 1 : Brute -> Hashing -> external ds

time : and space :

USING MAP :

public class Solution 
{
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) 
    {
        HashMap<ListNode,Integer> mpp=new HashMap<>();
        ListNode temp=headA;
        while(temp!=null)
        {
            mpp.put(temp,1);
            temp=temp.next;
        }
        temp=headB;
        while(temp!=null)
        {
            if(mpp.containsKey(temp))
            {
                return temp;
            }
            temp=temp.next;
        }
        return null;
    }
}

USING SET : 

public class Solution 
{
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) 
    {
        HashSet<ListNode> mpp=new HashSet<>();
        ListNode temp=headA;
        while(temp!=null)
        {
            mpp.add(temp);
            temp=temp.next;
        }
        temp=headB;
        while(temp!=null)
        {
            if(mpp.contains(temp))
            {
                return temp;
            }
            temp=temp.next;
        }
        return null;
    }
}

Approach 2 : better :

time : o(n1)+o(n2)+o(n2-n1)+o(n1) ==> o(n1)+o(n2)+o(n2) ==> o(n1+2n2)
space : o(1)

public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode temp1=headA;
        int t1=0;
        while(temp1!=null)
        {
            t1++;
            temp1=temp1.next;
        }
        ListNode temp2=headB;
        int t2=0;
        while(temp2!=null)
        {
            t2++;
            temp2=temp2.next;
        }
        if(t1<t2)
        {
           return  collisionpoint(headB,headA,t2-t1);
        }
        else
        {
            return collisionpoint(headA,headB,t1-t2);
        }
    }
    ListNode collisionpoint(ListNode lstA,ListNode lstB,int d)
    {
        if(lstA==null || lstB==null)
        {
            return  null;
        }
         while(d!=0)
         {
            d--;
            lstA=lstA.next;
         }
         ListNode tempA=lstA;
         ListNode tempB=lstB;
         while(tempA!=null)
         {
            if(tempA==tempB)
            {
                return tempA;
            }
            tempA=tempA.next;
            tempB=tempB.next;
         }
         return null;
    }
    
}

Approach 3 : optimal :

time : o(n) and space o(1)

public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA==null || headB==null)
        {
            return null;
        }
        ListNode t1=headA;
        ListNode t2=headB;
        while(t1!=t2)
        {
            t1 = (t1 == null) ? headB : t1.next;
            t2 = (t2 == null) ? headA : t2.next;
        }
        return t1;
    }
}
